# 范式设计及反范式设计

![db-design-nf](https://tva1.sinaimg.cn/large/008i3skNgy1grnyds5ubjj30m808wjtg.jpg)

通过前面的学习，我们知道，如果数据库符合三范式的基本要求，那么此数据库表基本上就解决了数据冗余过大，插入异常，修改异常和删除异常的问题。除了这三范式的要求之外，还存在的其他的范式要求，我们今天就来简单了解一下！

## BCNF范式

此范式与前面说的三大范式不同，三大范式每个范式前面都以数组命名，同时随着数组的增长，范式设计的要求就越高，后面的范式一旦成立，则前面的范式将必须也成立。但是这个范式并没有按照数字的命令，而是以人名：鲍依斯-科得范式来命名的。

这里有个问题，如果符合三范式设计的表，就一定不会存在插入异常、修改异常和删除异常了么？

要回答这个问题，我们先看一个例子吧！

一个学生可以学习多门课程，每个课程对应着一个老师，每个老师只能教一门课程，我们可以设计出如下的表：

|学生|课程|老师|
|:--:|:--:|:--:|
|张三|数学|李老师|
|张三|语文|张老师|
|李四|数学|李老师|
|李四|语文|刘老师|

毫无疑问，上面的表符合三范式的基本要求，但是依旧存在着：
* 插入异常：我们无法插入没有课程的学生，也无法插入没有教课的老师。
* 删除异常：如果我们要删除某个老师，那么将会删除这个老师所教课程的所有学生。
* 修改异常：如果我们要修改某个科目的老师，我们将修改关于很多学生学习此课程的老师。

所以，上面的数据库设计依旧不是很好的设计，到底是什么原因造成的呢？

我们发现：
* (学生 + 课程) -> 老师
* (课程 + 老师) -> 学生

所以，上面的表中存在的多个组合主键，多个组合的主键让这个表变得复杂了起来，这就是BCNF范式要解决的问题。

**数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖，则符合BC范式**

也就是说，如果数据库表中存在多个符合关键字，则复合关键字之间不能也不能存在函数依赖关系。

所以，对于上面的表，我们可以拆分为三个表：

* 学生表（学号，姓名，其他信息）
* 课程表（课程编号，课程名称，授课教师）
* 学生课程关系表（学号，课程编号）

这样，我们就解决了删除、插入和修改异常，符合BC范式啦！

## 反范式设计

我们经常遇到这样的场景，我们需要查询一个学生的信息的时候，需要经常知道这个学生所在的班级，而班级信息和学生信息又存在在两张表里面：

* student_info(student_id, name, age, sex, class_id)
* class_info(id, name)

所以，SQL写出来就是如下的结果：

```sql
select si.*, ci.name from student_info si
inner join class_info ci on si.class_id = ci.id
where si.name = “张三”
```

上面的SQL本身没有什么问题，大多数场景下都运行的很好，但是，如果当学生表里面的数据量非常庞大的时候，这个连接查询就变得非常耗时，这种情况下，我们可以适当的对学生表进行冗余，让班级名称也在学生表里面存在一份：

* student_info(student_id, name, age, sex, class_id, class_name)
* class_info(id, name)

我们在保留class_info表的同时，也在student_info表中保留了class_name的属性，这样就有了适当的冗余。那么查询SQL就变成：

```sql
select si.* from student_info si
where si.name = “张三”
```

毫无疑问，上面的查询SQL将变得更快。

上面的设计就是**反范式化设计**

**反范式化设计是针对范式设计而言的，所谓的反范式化设计就是为了性能和读取效率的考虑而适当的对数据库设计的范式要求进行违反，允许存在少量的数据冗余，换句话来说，反范式化就是使用空间来换取时间。**

所以，反范式化设计就是在性能需求与设计之间的权衡，这个权衡没有固定的要求，需要根据实际情况来做决策。

## 范式设计与反范式设计的利弊权衡

### 范式设计利弊

#### 优点
* 可以尽量减少数据的容易
* 范式化的更新操作比反范式化更快
* 范式化的表通常比反范式化的表更小

#### 缺点
* 对于查询来说，需要多个表进行关联
* 更难的进行查询索引优化

### 反范式设计利弊

#### 优点
* 更好的减少表的关联
* 更好的进行索引优化

#### 缺点
* 存在数据冗余和数据维护异常
* 对数据的修改需要更多的成本，适合于查询远远大于修改的场景

从上面的对比可以看出，完全的范式化设计和反范式化设计都不是数据库最佳设计方案，最佳的设计方案应该是在需求确定的基础上面以范式化为基本标准，适当的做一些反范式化的数据冗余，才能设计出高性能数据库结构。 